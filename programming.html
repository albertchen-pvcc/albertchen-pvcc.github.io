<!DOCTYPE html>
<html lang = "en">



<head>
    <title> Programming Algorithms & Software Testing </title>
    <style>
        h1 {background-color:crimson; font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif}
            th, td {
            border: 1px solid rgb(17, 17, 207);
            border-radius: 10px;
            border-style: outset;
            }
            table{width:850px; color:black; background-color: magenta;}
        a {text-decoration: none;}
        a:link {color: blue;}
        a:visited {color: purple;}
        a:hover {color: purple;}
        a:active {color: purple;}
</style>
</head>
<body style="background-image: url(computerprogram.jpg); font-family: 'Times New Roman', Times, serif;"></body>


<table border = "2" style ="width:50%; color:black; background-color:#e0c0ff; margin: auto; width: 800px;">
    <tr style="background-color: cyan;">
        <td><a href="https://albertchen-pvcc.github.io/index.html">Home</a></td>
        <td><a href="https://www.pvcc.edu/">PVCC</a></td>
        <td><a href="https://www.w3schools.com/">W3Schools</a></td>
        <td><a href="https://docs.google.com/forms/d/e/1FAIpQLScNeoPLUBehqmF6nF24DX2otrLMB-fPD61TYiILO98qP95jMg/viewform?embedded=true">Contact Us</a></td>
    </tr>
    <tr>
        <td colspan="4"> <h1>Programming Algorithms & Software Testing</h1> </td>
    </tr>
    <tr>
        <td colspan="4">

            <table border = "1" style ="width:100%; color: black;margin: auto; background-color:rgb(192, 20, 20);">
            <tr>
                <td> <b>Term</b> </td>
                <td> <b>Definition</b> </td>
            </tr>
            
            <tr>
                <td>Phases of computer program development</td>
                <td>
                    <ul>
                        <li>1: Understand the problem</li>
                        <li>2: Design an algorithm to solve the problem</li>
                        <li>3: Write the program code in appropriate language based on the algorithm</li>
                        <li>4: Enter the program and save</li>
                        <li>5: Execute the program</li>
                        <li>6: Test the program, find errors and debug, then retest</li>
                        <li>7: Document and evaluate the program</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Programming structures</td>
                <td>
                    <ul>
                        <li>Sequential structure: Top-down execution</li>
                        <li>Decision structures: if/then/else</li>
                        <dt><li>Iterative (Looping)</li></dt>
                        <ol>
                            <li>While loop: continue looping as long as something is true</li>
                            <li>Repeat/until loop: continue looping as long as something is true</li>
                            <li>for loop: loop a given number of times</li>
                        </ol>
                        <dt><li>Recursive structures: </li></dt>
                        <ol>
                            <li>Repeat a set of instructions as a subtask of itself</li>
                            <li>Repetition continues until: </li>
                        </ol>
                        <dd>-Degenerative case, which is when a termination condition is met</dd>
                        <dd>-(degenerative case is also called a "base case")</dd>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Two classic programming/database problems</td>
                <td>
                    <ul>
                        <dt><li>Sorting: Descending order/Ascending order</li></dt>
                        <dd>Sorting numbers</dd>
                        <dd>Sorting strings (in accordance with ASCII values)</dd>
                        <dt><li>Searching: find specific data that meet a certain criteria</li></dt>
                        <dd>In database: </dd>
                        <dd>-Filters: temporary search</dd>
                        <dd>-Queries: search criteria are saved so they don't have to be recreated</dd>
                        <dt><li>Two popular search techniques: </li></dt>
                        <dd>1. Sequential search: search from top to bottom or bottom to top, one item at a time</dd>
                        <dd>2. Binary search: </dd>
                        <dd>-only works if data is SORTED first</dd>
                        <dd>-start in the middle, then go to half of that, etc.</dd>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Two classic program goals</td>
                <td>
                    <ul>
                        <li>Efficiency: Program takes minimal time and/or resources</li>
                        <li>Correctness: Program runs in expected ways and works for all expected conditions</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Software testing and verification</td>
                <td>
                    <ul>
                        <li>Kinds of tests: </li>
                        <ul>
                            <li>Acceptance Testing: Verifying whether the whole system works as intended.</li>
                            <li>Code review: Confirming that new and modified software is following an organization's coding standards and adheres to its best practices.</li>
                            <li>Integration Testing: Ensuring that software components or functions operate together.</li>
                            <li>Unit testing: Validating that each software unit runs as expected. A unit is the smallest testable component of an application.</li>
                            <li>Functional testing: Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.</li>
                            <li>Performance testing: Testing how the software runs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.</li>
                            <li>Regression testing: Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.</li>
                            <li>Security testing: Validating that your software is not open to hackers or other malicious types of vulnerabilities that might be exploited to deny access to your services or cause them to perform incorrectly.</li>
                            <li>Stress testing: Testing how much strain the system can take before it fails. Stress testing is considered to be a type of non-functional testing.</li>
                            <li>Usability testing: Validating how well a customer can use a system or web application to complete a task.</li>
                        </ul>
                        <li>Software testing is designed to detect: </li>
                        <ul>
                            <li>Architectural flaws</li>
                            <li>Poor Design Decisions</li>
                            <li>Invalid or Incorrect Functionality</li>
                            <li>Security vulnerabilities</li>
                            <li>Scalability Issues</li>
                        </ul>
                        <li>Testing best practices: </li>
                        <ul>
                            <li>1. Continous testing: When creating a software project, teams regularly check each version of the software as it's developed. They use automated testing tools that are part of the deployment process. This helps validate the software in real-life situations early on, which makes the design better and lowers the chances of problems later.</li>
                            <li>2. Configuration management: In organizations, important testing materials are stored in one central place, and it's easy to keep track of which versions of the software need testing. Teams can access various materials like code, requirements, design documents, models, test scripts, and results. Effective systems have security measures and records to ensure teams follow rules without needing a lot of administrative work.</li>
                            <li>3. Service virtualization: When developing code, testing environments might not be ready, especially in the early stages. Service virtualization helps by mimicking missing or incomplete services and systems. This allows teams to test without relying on everything being in place. They can easily reuse, deploy, and adjust configurations to test various scenarios without changing the original environment.</li>
                            <li>4. Defect or "bug tracking": Both testing and development teams find it crucial to keep an eye on defects to gauge and enhance the quality of their work. Automated tools help them keep track of defects, understand how widespread and impactful they are, and identify any related issues.</li>
                            <li>5. Metrics and Reporting: Reporting and analytics help team members share updates, goals, and test results. Advanced tools bring together project metrics and display results on a dashboard. This allows teams to quickly understand the overall status of a project and keep an eye on connections between testing, development, and other project components.</li>
                        </ul>
                        <li><a href="https://www.ibm.com/topics/software-testing">From: IBM What is software testing?</a></li>
                    </ul>
                </td>
            </tr>
        </table>
</body></html>